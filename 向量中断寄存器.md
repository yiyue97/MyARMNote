### 目录

<!-- TOC -->

- [目录](#目录)
- [中断寄存器](#中断寄存器)
	- [VIC 控制寄存器](#vic-控制寄存器)
	- [VIC参数设置寄存器](#vic参数设置寄存器)
		- [VICVectCntlx[0:15] 向量控制寄存器](#vicvectcntlx015-向量控制寄存器)
		- [VICVectAddrx 向量地址寄存器 0~15](#vicvectaddrx-向量地址寄存器-015)
		- [VICDefVectAddr 默认向量地址寄存器](#vicdefvectaddr-默认向量地址寄存器)
		- [VICVectAddr 向量地址寄存器](#vicvectaddr-向量地址寄存器)
- [状态寄存器 (均为32bit)](#状态寄存器-均为32bit)
- [FIQ中断](#fiq中断)
	- [将外部中断0(EINT0)分配为FIQ，并编写FIQ服务程序](#将外部中断0eint0分配为fiq并编写fiq服务程序)
- [向量IRQ中断](#向量irq中断)
	- [IRQ服务程序](#irq服务程序)
	- [将定时器0(Timer0)分配为向量IRQ通道0，中断服务程序地址设置为Timer0_ISR](#将定时器0timer0分配为向量irq通道0中断服务程序地址设置为timer0_isr)
- [非向量IRQ中断](#非向量irq中断)
	- [将外部中断0(EINT0)分配为非向量IRQ，并编写中断服务程序](#将外部中断0eint0分配为非向量irq并编写中断服务程序)
- [用中断的方法实现 [键控开关 - 蜂鸣器开关电路]](#用中断的方法实现-键控开关---蜂鸣器开关电路)
	- [FIQ中断](#fiq中断-1)
	- [向量IRQ中断](#向量irq中断-1)
	- [非向量IRQ中断](#非向量irq中断-1)

<!-- /TOC -->



![1538559072151.png](https://i.loli.net/2018/10/04/5bb5fa0013340.png)

|        中断类型         |     优先级     |
| :---------------------: | :------------: |
| FIQ中断（快速中断请求） | 具有最高优先级 |
|       向量IRQ中断       | 具有中等优先级 |
|      非向量IRQ中断      | 具有最低优先级 |



20个中断请求输入，12个未使用。16个向量IRQ中断。中断源看课本 P190 - 191。



### 中断寄存器

#### VIC 控制寄存器

1. 选择产生中断的类型
  1. 中断选择寄存器 [ `VICIntSelect` ]
  2. 32bit。第某位写入1时，对应中断源产生的中断为FIQ。写入0，则为IRQ中断。
2. 允许中断源产生中断
  1. 中断使能寄存器 [ `VICIntEnable` ]
  2. 32bit。第某位写入1时，允许对应的中断源产生中断。
  3. 使用：`VICIntEnable = 1 << 14; // 使能EINT0中断`
3. 清零寄存器
  1. 中断使能清零寄存器 [ `VICIntEnClear` ] 
  2. 32bit。与中断使能寄存器功能相反。第某位写入1时，禁止对应的中断源产生中断。





#### VIC参数设置寄存器

- 向量 IRQ 中断相关寄存器

  - 向量控制寄存器 [ `VICVectCntlx[0:15]` ]
  - `VICVectAddrx` 向量地址寄存器0~15
- 非向量 IRQ 中断相关寄存器

  -  默认向量地址寄存器 [ `VICDefVectAddr` ]
  -   用法同 `VICVectAddrx`
- 产生中断后的服务程序地址
  - 向量地址寄存器 [ `VICVectAddr` ]



##### VICVectCntlx[0:15] 向量控制寄存器

1. 32bit。向量IRQ通道0的优先级最高，向量IRQ通道15的优先级最低。
2. 使用 `VICVectCntlx = 0x20 | 中断源序号;  // VICVectCntlx = (1 << 5) | 中断源序号`

|  位  | 31 : 6 |        5        |   [4:0]    |
| :--: | :----: | :-------------: | :--------: |
| 功能 |  保留  | EN(向量IRQ使能) | 中断源序号 |



##### VICVectAddrx 向量地址寄存器 0~15

1. 32bit。该寄存器中存放对应优先级向量IRQ中断服务程序的入口地址。
2. 使用：假设中断服务程序地址为 Timer0_ISR。

```c
void __irq Timer0_ISR(void)
{
	[中断处理]
	T0IR = 0x01; // 清楚定时器0的标志
	VICVectAddr = 0x00; // 通知VIC中断处理结束
}
...
VICVectAddrx = (unsigned int)Timer0_ISR //就是那个中断函数名啦
```



##### VICDefVectAddr 默认向量地址寄存器

用法同VICVectAddrx。

##### VICVectAddr 向量地址寄存器

用于存放 IRQ 中断服务程序地址。当发生一个IRQ中断后，CPU读取该寄存器并跳转到对应地址处，执行中断服务程序。不能直接赋值给它。该寄存器的值从VICVectAddr0~15或VICDefVectAddr中复制得到。

注意：需要在中断服务程序最后将其清零。

`VICVectAddr = 0x00;`





### 状态寄存器 (均为32bit)

具体看书p198。

* VICIRQStatus(IRQ状态寄存器)
  * 读取该寄存器可确定哪些中断被激活。当某位为1时表示对应位的中断源产生IRQ中断请求。
* VICFIQStatus(FIQ状态请求寄存器)
  * 当某位为1时表示对应位的中断源产生FIQ中断请求。
* VICRawIntr(所有中断的状态寄存器)
  * 当某位为1时表示对应位的中断源产生中断请求。





### FIQ中断

>  课本 P200 - 204



* FIQ中断使能函数 `FIQEnable();`
* FIQ中断禁止函数 `FIQDisable();`



```c
// FIQ服务程序
void FIQ_Exception(void)
{
	[FIQ中断处理]
	...
}
```



#### 将外部中断0(EINT0)分配为FIQ，并编写FIQ服务程序

> 课本 P201



```C
// 初始化
FIQEnable(); 			//使能FIQ中断(课本没有这行，这是必须的)
VICIntSelect = (1 << EINT0_num);  //EINT0分配为FIQ中断
EXTINT = 0X01; 			//清除EINT0中断标志(详细说明见外部中断)
VICIntEnable = (1<<EINT0_num);  //使能EINT0中断

//FIQ服务程序
void FIQ_Exception(void)
{
	[FIQ中断处理]
	while ((EXTINT & 0x01) != 0) {
		EXTINT = 0x01; 	//清除EINT0中断标志
	}
}
```







### 向量IRQ中断

> 课本 P204 - 210

* IRQ 中断使能函数 `IRQEnable();`
* IRQ 中断禁止函数 `IRQDisable();`

#### IRQ服务程序

```c
// xxx为中断服务程序地址，即函数名
void __irq xxx(void)
{
	[中断处理]
	...
	VICVectAddr = 0x00; // 通知 VIC 中断处理结束
}
```

#### 将定时器0(Timer0)分配为向量IRQ通道0，中断服务程序地址设置为Timer0_ISR

>  课本 P206 - 207

```c
// 初始化
IRQEnable();				// 使能IRQ(课本没有这行，这是必须的)
VICIntSelect = 0x00;  			// 所有中断通道均设为IRQ中断
VICVectCntl0 = 0x20 | Timer0_num;		// 等价于 VICVectCntl0 = (1 << 5) | Timer0_num;
// 将定时器0分配为通道0
VICVectAddr0 = (unsigned int)Timer0_ISR; // 清除Timer0中断服务程序地址
T0IR = 0x01;				// 清除Timer0中断标志
VICIntEnable = (1 << Timer0_num);	// 使能Timer0中断

// IRQ服务程序
void __irq Timer0_ISR(void)
{
	[中断处理]
	T0IR = 0x01;		// 清除中断标志
	VICVectAddr = 0x00;	// 通知 VIC 中断处理结束
}
```







### 非向量IRQ中断

>  课本 P210 - 212

在向量IRQ够用的情况下，最好不要使用非向量IRQ中断。

也要用到IRQ中断使能函数。若要将向量IRQ中断改为非向量IRQ中断，只需把 **VICVectCntlx** 和 **VICVectAddrx** 两行代码改为 **VICDefVectAddr = (unsigned int)中断服务程序地址**。

#### 将外部中断0(EINT0)分配为非向量IRQ，并编写中断服务程序

>  课本 P211

```c
//初始化
IRQEnable();					 // 使能IRQ(课本没有这行，这是必须的)
VICIntSelect = 0x00;				 // 设置所有中断为IRQ中断
VICDefVectAddr = (unsigned int)Eint0_ISR; // 设置中断服务程序地址
EXTINT = 0X01;					 // 清除EINT0中断标志
VICIntEnable = (1 << EINT0_num);		// 使能EINT0中断

//中断服务程序
void __irq Eint0_ISR(void)
{
	[中断处理]
	while((EXTINT&0x01)!=0) {
		EXTINT = 0x01; 		//清除EINT0中断标志
	}
	VICVectAddr = 0; 		//向量中断结束
}
```





### 用中断的方法实现 [键控开关 - 蜂鸣器开关电路]



#### FIQ中断

```c
#define BUZZ 1<<7

void FIQ_Exception(void)
{
	flag = !falg;
	if (flag == 0)
		IO0CLR = BUZZ;
	else
		IO0SET = BUZZ;
	EXTINT = 1 << 3;	//清除EINT3中断标志
	VICVectAddr = 0;	//这是硬件决定的，有些要清0有些不用，可不写
}

int main(void)
{
	int flag = 0;		// 标志蜂鸣器
	FIQEnable();		// 使能FIQ中断
	PINSEL0 = 0x00;		// 配置p0.7为GPIO口
	PINSEL1 = 3 << 8;	// 配置P0.20为EINT3
	IO0DIR |= BUZZ;		// 配置p0.7为输出
	VICIntSelect = 1 << 17;	// 使能EINT3中断
	EXTMODE = 0X00;		// EINT3中断为电平触发模式
	EXTPOLAR = 0x00;	// EIN3中断为低电平触发
	EXTINT = 1 << 3;	// 清除EINT3中断标志
	VICIntEnable = 1 << 17;	// 允许EINT3中断
	while (1) {}		// 等待中断
	return 0;
}
```

#### 向量IRQ中断

```c
void __irq IRQ_Eint3(void)
{
	flag = !flag;
	if (flag == 0)
		IO0CLR = BUZZ;
	else
		IO0SET = BUZZ;
	EXTINT = 1 << 3;	// 清除EINT3中断标志
	VICVectAddr = 0; 	// 必须的，清0，向量中断结束
}

void main(void)
{
	int flag = 0;			// 标志蜂鸣器
	IRQEnable();			// 使能IRQ中断
	PINSEL0 = 0x00;			// 配置p0.7为GPIO口
	PINSEL1 = 3 << 8;		// 配置P0.20为EINT3
	IO0DIR |= BUZZ;			// 配置p0.7为输出
	VICIntSelect = 0x00;		// 所有中断分配为IRQ中断
	VICVectCntl0 = (1 << 5) | 17;	// EINT3分配为通道0
	VICVectAddr0 = (int)IRQ_Eint3;	// 中断服务程序地址
	EXTMODE = 0x00;			// EINT3中断为电平触发模式
	EXTPOLAR = 0x00;		// EIN3中断为低电平触发
	EXTINT = 1 << 3;		// 清除EINT3中断标志
	VICIntEnable = 1 << 17;		// 允许EINT3中断
	while (1) {}			// 等待中断
}
```

#### 非向量IRQ中断

将向量 IRQ 里

```c
VICVectCntl0 = (1 << 5) | 17;	// EINT3分配为通道0
VICVectAddr0 = (int)IRQ_Eint3;	// 中断服务程序地址
```

这两句换成

```c
VICDefVectAddr = (int)IRQ_Eint3; // 中断服务程序地址
```

完整版代码如下

```c
void __irq IRQ_Eint3(void)
{
	flag = !flag;
	if (flag == 0)
		IO0CLR = BUZZ;
	else
		IO0SET = BUZZ;
	EXTINT = 1 << 3;		//清除EINT3中断标志
	VICVectAddr = 0; 		//必须的，清0，向量中断结束
}

int main(void)
{
	int flag = 0;			// 标志蜂鸣器
	IRQEnable();			// 使能IRQ中断
	PINSEL0 = 0x00;			// 配置p0.7为GPIO口
	PINSEL1 = 3 << 8;		// 配置P0.20为EINT3
	IO0DIR |= BUZZ;			// 配置p0.7为输出
	VICIntSelect = 0x00;		// 所有中断分配为IRQ中断

	VICDefVectAddr = (int)IRQ_Eint3; // 中断服务程序地址

	EXTMODE = 0x00;			// EINT3中断为电平触发模式
	EXTPOLAR = 0x00;		// EIN3中断为低电平触发
	EXTINT = 1 << 3;		// 清除EINT3中断标志
	VICIntEnable = 1 << 17;		// 允许EINT3中断
	while (1) {}			// 等待中断
}
```

